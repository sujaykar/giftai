import OpenAI from 'openai';
import { storage } from '../storage';
import { Product, InsertProductTag } from '@shared/schema';

// the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });

interface ExtractedTags {
  categories: string[];
  occasions: string[];
  moods: string[];
  age_ranges: string[];
  genders: string[];
  relationships: string[];
  interests: string[];
  general_tags: string[];
}

/**
 * Auto-generates tags for a product using AI
 */
export async function autoGenerateProductTags(product: Product): Promise<InsertProductTag[]> {
  try {
    const productInfo = `
      Product: ${product.name}
      Description: ${product.description || ''}
      Price: ${product.price ? `$${product.price}` : 'Unknown price'}
      Category: ${product.category || ''}
    `;

    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `
            You are a product tagging specialist for a gift recommendation platform.
            Analyze the product information and extract appropriate tags for gift categorization.
            For each category, provide only the most relevant tags (maximum 5 per category).
            If a category doesn't apply, return an empty array for that category.
          `
        },
        {
          role: "user",
          content: productInfo
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.7,
    });

    const extractedTags = JSON.parse(response.choices[0].message.content) as ExtractedTags;
    const productTags: InsertProductTag[] = [];

    // Process categories
    if (extractedTags.categories && extractedTags.categories.length > 0) {
      extractedTags.categories.forEach(category => {
        productTags.push({
          productId: product.id,
          tagType: 'category',
          tagValue: category,
          confidence: 0.85,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process occasions
    if (extractedTags.occasions && extractedTags.occasions.length > 0) {
      extractedTags.occasions.forEach(occasion => {
        productTags.push({
          productId: product.id,
          tagType: 'occasion',
          tagValue: occasion,
          confidence: 0.8,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process moods
    if (extractedTags.moods && extractedTags.moods.length > 0) {
      extractedTags.moods.forEach(mood => {
        productTags.push({
          productId: product.id,
          tagType: 'mood',
          tagValue: mood,
          confidence: 0.75,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process age ranges
    if (extractedTags.age_ranges && extractedTags.age_ranges.length > 0) {
      extractedTags.age_ranges.forEach(ageRange => {
        productTags.push({
          productId: product.id,
          tagType: 'age_range',
          tagValue: ageRange,
          confidence: 0.7,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process genders
    if (extractedTags.genders && extractedTags.genders.length > 0) {
      extractedTags.genders.forEach(gender => {
        productTags.push({
          productId: product.id,
          tagType: 'gender',
          tagValue: gender,
          confidence: 0.8,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process relationships
    if (extractedTags.relationships && extractedTags.relationships.length > 0) {
      extractedTags.relationships.forEach(relationship => {
        productTags.push({
          productId: product.id,
          tagType: 'relationship',
          tagValue: relationship,
          confidence: 0.75,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process interests
    if (extractedTags.interests && extractedTags.interests.length > 0) {
      extractedTags.interests.forEach(interest => {
        productTags.push({
          productId: product.id,
          tagType: 'interest',
          tagValue: interest,
          confidence: 0.7,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    // Process general tags
    if (extractedTags.general_tags && extractedTags.general_tags.length > 0) {
      extractedTags.general_tags.forEach(tag => {
        productTags.push({
          productId: product.id,
          tagType: 'tag',
          tagValue: tag,
          confidence: 0.65,
          isAutoGenerated: true,
          source: 'ai'
        });
      });
    }

    return productTags;
  } catch (error) {
    console.error('Error generating product tags:', error);
    return [];
  }
}

/**
 * Updates the product's array fields with the extracted tags
 */
export async function updateProductArrays(product: Product, tags: InsertProductTag[]): Promise<void> {
  try {
    const categoriesSet = new Set<string>();
    const occasionsSet = new Set<string>();
    const moodsSet = new Set<string>();
    const ageRangesSet = new Set<string>();
    const gendersSet = new Set<string>();
    const relationshipsSet = new Set<string>();
    const interestsSet = new Set<string>();
    const tagsSet = new Set<string>();

    // Populate from existing arrays if they exist
    if (product.categories) {
      product.categories.forEach(cat => categoriesSet.add(cat));
    }
    if (product.occasions) {
      product.occasions.forEach(occ => occasionsSet.add(occ));
    }
    if (product.moods) {
      product.moods.forEach(mood => moodsSet.add(mood));
    }
    if (product.ageRanges) {
      product.ageRanges.forEach(age => ageRangesSet.add(age));
    }
    if (product.genders) {
      product.genders.forEach(gender => gendersSet.add(gender));
    }
    if (product.relationships) {
      product.relationships.forEach(rel => relationshipsSet.add(rel));
    }
    if (product.interests) {
      product.interests.forEach(int => interestsSet.add(int));
    }
    if (product.tags) {
      product.tags.forEach(tag => tagsSet.add(tag));
    }

    // Add new tags
    tags.forEach(tag => {
      switch (tag.tagType) {
        case 'category':
          categoriesSet.add(tag.tagValue);
          break;
        case 'occasion':
          occasionsSet.add(tag.tagValue);
          break;
        case 'mood':
          moodsSet.add(tag.tagValue);
          break;
        case 'age_range':
          ageRangesSet.add(tag.tagValue);
          break;
        case 'gender':
          gendersSet.add(tag.tagValue);
          break;
        case 'relationship':
          relationshipsSet.add(tag.tagValue);
          break;
        case 'interest':
          interestsSet.add(tag.tagValue);
          break;
        case 'tag':
          tagsSet.add(tag.tagValue);
          break;
      }
    });

    // Update product
    await storage.updateProduct(product.id, {
      categories: Array.from(categoriesSet),
      occasions: Array.from(occasionsSet),
      moods: Array.from(moodsSet),
      ageRanges: Array.from(ageRangesSet),
      genders: Array.from(gendersSet),
      relationships: Array.from(relationshipsSet),
      interests: Array.from(interestsSet),
      tags: Array.from(tagsSet)
    });
  } catch (error) {
    console.error('Error updating product arrays:', error);
  }
}

/**
 * Process all products and generate tags
 */
export async function batchProcessProducts(): Promise<void> {
  try {
    const products = await storage.getProducts();
    console.log(`Processing ${products.length} products for auto-tagging...`);
    
    for (const product of products) {
      console.log(`Generating tags for product: ${product.name}`);
      const tags = await autoGenerateProductTags(product);
      
      if (tags.length > 0) {
        // Store tags in the product_tags table
        await storage.createProductTags(tags);
        
        // Update product arrays for quick filtering
        await updateProductArrays(product, tags);
        
        console.log(`Added ${tags.length} tags to product: ${product.name}`);
      }
    }
    
    console.log('Batch product tagging complete');
  } catch (error) {
    console.error('Error in batch processing products:', error);
  }
}